<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        class Animal{

        }

        class Dog extends Animal{

        }

        const dog = new Dog()

        /*
            instanceof 用来检查一个对象是否是一个类的实例
                - instanceof检查的是对象原型链上是否有改类的实例
                    只要原型链上有该类的实例，就会返回true

                - dog -> Animal的实例 -> Object实例 -> Object原型

                - Object是所有对象的原型,所以任何和对象和Object进行instanceof运算都会返回true
        */

        //检查dog对象是否是Dog类的实例
        console.log(dog instanceof Dog)//true
        console.log(dog instanceof Animal)//true
        console.log(dog instanceof Object)//true

        const obj = new Object()

        //通过.__proto__访问原型对象
        console.log(obj.__proto__)

        //通过类.prototype属性访问原型对象
        console.log(Object.prototype)

        //访问dog对象的原型对象
        console.log(Dog.prototype)


        class Person {
            name = "孙悟空";
            age = 18;
            sayHello() {
              console.log("我是", this.name);
            }
          }
        //实例对象
        const p = new Person()

        /*
            - 使用in运算符时，无论属性在对象自身中还是在原型中，都会返回true
            
            对象.hasOwnProperty(属性名)      不推荐使用
                - 用来检查一个对象自身是否含有某个属性

            Object.hasOwn(对象,属性名)       推荐使用这种方式
                - 检查对象自身是否含有某个属性

        */
        console.log("sayHello" in p)
        
        console.log(p.hasOwnProperty("name"))//true
        console.log(p.hasOwnProperty("sayHello"))//false
        //说明hasOwnProperty是存储在原型对象中
        console.log(p.__proto__.__proto__.hasOwnProperty("hasOwnProperty"))//true

        console.log(Object.hasOwn(p,"name")) //true
        console.log(Object.hasOwn(p,"sayHello")) //false
        


    </script>
</body>
</html>