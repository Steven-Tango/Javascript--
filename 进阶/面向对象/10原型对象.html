<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      class Person {
        name = "孙悟空";
        age = 18;
        sayHello() {
          console.log("我是", this.name);
        }
      }

      const p = new Person();

      /*
            访问一个对象的原型对象   
                对象.__proto__
                Object.getPrototypeOf(对象) 
                
            原型对象中的数据：
                1.对象中的数据  比如属性 方法
                2.constructor （对象的构造函数）

            注意：
                原型对象也有原型,这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同
                p对象的原型链：p对象 --> 原型 --> 原型 --> null
                obj对象的原型链:obj对象 --> 原型 --> null

            原型链:
                读取对象属性时,会优选读取对象自身属性,
                    如果对象中有,则能使用,没有,则去对象的原型中寻找
                    如果原型中有,则使用,没有,则去原型的原型中寻找
                    直到找到Object对象的原型,Object的原型,没有原型(null)
                    如果还没有找到,则返回undefined

            作用域链是找变量的链,找不到报错
            原型链是找属性的链,找不到返回undefined
        */

      console.log(p.__proto__.__proto__);
      //console.log(p.__proto__.__proto__.__proto__);
      console.log(Object.getPrototypeOf(p));

      //console.log(p.__proto__);

      console.log(p);

      const obkj = {};
    </script>
  </body>
</html>
